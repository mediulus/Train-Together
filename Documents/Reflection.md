# Reflection on My Project Experience

## What Went Well

**Learning through Iteration:** From defining my domain and problem scope to final implementation, I learned to reflect deeply on user experiences and how software could improve them.

**Conceptual Clarity:** After meeting with my TA, I realized my concept actions were overly dependent on each other. Once I separated them, my implementation became smoother and my syncs more meaningful.

**Decision-Making:** I learned to make trade-offs based on feasibility and impact—for instance, choosing to build my own user logging UI instead of fetching data from unverified Google Sheets. This taught me how to prioritize efficiently.

## What Was Challenging

**Concept Design:** Early on, I struggled to understand modularity and the boundaries between concepts. My specs were vague and hard to implement, but this experience helped me realize the importance of designing with clear, independent responsibilities.

**Front-End Development:** While I gained confidence connecting the front and back ends, I still find UI design challenging. I want to improve my ability to make interfaces both functional and visually appealing.

## Skills Gained and Areas for Growth

# Acquired Skills:

- Stronger understanding of full-stack development and the flow between front-end and back-end components.

- Improved debugging and problem decomposition skills through iterative testing and implementation.

# Future Development:

- Enhancing front-end aesthetics and design intuition.

- Continuing to practice modular thinking early in design to simplify later implementation.

## Use of Tools

**Context Tool:** Very helpful when initially implementing the concepts, but I did not use it much after

**Agentic Coding (Copilot & ChatGPT):** I used Copilot within VS Code for inline coding help and ChatGPT for higher-level reasoning and debugging. This dual approach made development faster and more educational.

## Reflections on LLMs in Software Development

**Appropriate Role:** LLMs are most effective as collaborative assistants—useful for brainstorming, boilerplate generation, and clarifying design ideas—but not as replacements for understanding.

**Prompt Engineering:** I learned to break big tasks into smaller, guided prompts, improving both accuracy and my own comprehension.

## Conclusion

This project gave me both technical and personal growth. I learned how to design modularly, make efficient decisions, and leverage LLMs as learning partners rather than shortcuts. Most importantly, I walked away with something I can confidently call my own.